C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 1
OBJECT MODULE PLACED IN 1.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE 1.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*****12M晶振stc89c52单片机*********************/
   2          
   3          
   4          #include<reg52.h>
   5          #include<intrins.h>
   6          #define uint unsigned int
   7          #define uchar unsigned char
   8          #define LED_CON P2      //位选端口
   9          
  10          uchar second1,second2,minute1,minute2,hour1,hour2,day1,day2,month1,month2,week1,week2,year1,year2;
  11          uchar time_data[7];//显示缓冲区
  12          uchar  table[]={0Xc0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90};   //0―9段码
  13          uchar table_dp[]={0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10}; //带秒闪0―9段码数组
  14          //uchar  bufer[]={0x7f,0xbf,0xdf,0xef}; //数码管位选
  15           uchar code table2[]={0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x05,0x06,0x06,0x06,0x07,0x08,0x08,0x09,0x09
             -};//小数查表
  16          uchar second,minute,hour,month=1,week=1,day=1,year;  //调整日期参数
  17          uint temp,flag,ch; //显示温度参数
  18          uchar time_flag; //调整时间标志位
  19          bit bell_flag;//整点报时标志位
  20          
  21          
  22               
  23          sbit sck=P1^0;//1302时钟线
  24          sbit io=P1^1; //1302信号线
  25          sbit rst=P1^2;//1302复位线
  26          
  27          sbit dq=P1^3;//DS18B20数据引脚  
  28            
  29          sbit bell1 = P1^4; //闹铃开关指示灯 
  30           
  31          
  32          sbit bell = P2^0;  //整点报时
  33          
  34          
  35          
  36          sbit KEY20 = P3^2;
  37          sbit KEY21 = P3^3;
  38          sbit KEY22 = P3^4;
  39          sbit KEY23 = P3^5;
  40          
  41          /*ds1302驱动程序*/
  42           
  43            void write_ds1302_byte(uchar dat)     //写单字节
  44            {uchar i;
  45   1         for(i=0;i<8;i++)
  46   1         {sck=0;
  47   2          io=dat&0x01;
  48   2              dat>>=1;
  49   2              sck=1;
  50   2         }
  51   1        }
  52          
  53          
  54            void write_ds1302(uchar add,uchar dat)
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 2   

  55            {rst=0;
  56   1         _nop_();
  57   1         sck=0;
  58   1         _nop_();
  59   1         rst=1;
  60   1         _nop_();
  61   1         write_ds1302_byte(add);
  62   1         write_ds1302_byte(dat);
  63   1         rst=0;
  64   1         _nop_();
  65   1         io=1;
  66   1         sck=1;
  67   1         }
  68            
  69            uchar read_ds1302(uchar add)
  70            
  71            {uchar i,value;
  72   1          rst=0;
  73   1          _nop_();
  74   1              sck=0;
  75   1              _nop_();
  76   1              rst=1;
  77   1              _nop_();
  78   1              write_ds1302_byte(add);
  79   1              for(i=0;i<8;i++)
  80   1              {
  81   2              value=value>>1;
  82   2              sck=0;
  83   2              if(io)
  84   2              value=value|0x80;
  85   2              sck=1;
  86   2              }
  87   1              rst=0;
  88   1              _nop_();
  89   1              sck=0;
  90   1              _nop_();           
  91   1              sck=1;
  92   1              io=1;
  93   1              return value;
  94   1       }
  95                  
  96          
  97           void set_rtc(uchar add,value)//设定时钟函数注意 BCD码的转换
  98          { 
  99   1        uchar temp,temp1,temp2;
 100   1        write_ds1302(0x8e,0x00);//去除写保护
 101   1        temp1=value/10; //分离十位
 102   1        temp2=value%10;//分离个位
 103   1        temp=temp2+temp1*16; //转换完成BCD码
 104   1        write_ds1302(add,temp);
 105   1        write_ds1302(0x8e,0x80); //加上写保护
 106   1      }       
 107          
 108          void read_rtc(void)//读取时钟函数
 109          {
 110   1      time_data[0]=read_ds1302(0x8d); //读年份
 111   1      time_data[1]=read_ds1302(0x8b); //读星期
 112   1      time_data[2]=read_ds1302(0x89); //读月
 113   1      time_data[3]=read_ds1302(0x87); //读日
 114   1      time_data[4]=read_ds1302(0x85); //读时
 115   1      time_data[5]=read_ds1302(0x83); //读分
 116   1      time_data[6]=read_ds1302(0x81); //读秒
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 3   

 117   1      }
 118          
 119          
 120          
 121          void time_proce() //数据处理函数把数据转换为相应的10进制数
 122          {   second1=time_data[6]/16; //转换为10进制数高位
 123   1          second2=time_data[6]%16     ;//转换为10进制数低位
 124   1          minute1=time_data[5]/16;
 125   1          minute2=time_data[5]%16     ;
 126   1          hour1=time_data[4]/16 ;
 127   1          hour2=time_data[4]%16 ;
 128   1          day1=time_data[3]/16;
 129   1          day2=time_data[3]%16;
 130   1              month1=time_data[2]/16;
 131   1          month2=time_data[2]%16;
 132   1              week1=time_data[1]/16;
 133   1          week2=time_data[1]%16;
 134   1              year1=time_data[0]/16;
 135   1          year2=time_data[0]%16;
 136   1      }
 137          
 138          /*******数码管显示程序************/
 139          
 140          void delay(uint z)    //延时
 141          {
 142   1          uint x,y;
 143   1          for(x=0;x<z;x++)
 144   1              for(y=0;y<110;y++);
 145   1      }
 146          
 147          
 148          void disp_time()//数码显示时间函数
 149          {
 150   1          LED_CON&=0X0f;       //保持低4位数据不变,高4位清零
 151   1              LED_CON|=(0xef&0xf0);//
 152   1      
 153   1          P0=table[hour1];
 154   1          delay(2);
 155   1      
 156   1          LED_CON&=0X0f;       //保持低4位数据不变
 157   1              LED_CON|=(0xdf&0xf0);//
 158   1              if(second2%2==0)
 159   1          P0=table[hour2]; 
 160   1          else
 161   1              P0=table_dp[hour2];
 162   1              delay(2);
 163   1      
 164   1          LED_CON&=0X0f;       //保持低4位数据不变
 165   1              LED_CON|=(0xbf&0xf0);//
 166   1          P0=table[minute1];
 167   1          delay(4);   
 168   1      
 169   1          LED_CON&=0X0f;       //保持低4位数据不变
 170   1              LED_CON|=(0x7f&0xf0);//
 171   1          P0=table[minute2];
 172   1          delay(4);
 173   1      
 174   1       }
 175          
 176           //整点报时程序
 177           void bell_clock()
 178           {
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 4   

 179   1       
 180   1      if((second1==0)&&((second2<6)&&(second2>=0))&&(minute1==0)&&(minute2==0)&&(bell_flag==0)) //整点报时
 181   1      bell=0;
 182   1      else
 183   1      bell=1;
 184   1      
 185   1       
 186   1       }
 187          
 188          void disp_set_time()//数码显示闹铃函数
 189          {
 190   1          LED_CON&=0X0f;       //保持低4位数据不变,高4位清零
 191   1              LED_CON|=(0xef&0xf0);//
 192   1      
 193   1          P0=table[hour/10];
 194   1          delay(2);
 195   1      
 196   1          LED_CON&=0X0f;       //保持低4位数据不变
 197   1              LED_CON|=(0xdf&0xf0);//
 198   1      //      if(second2%2==0)
 199   1         P0=table[hour%10]; 
 200   1      //   else
 201   1      //      P0=table_dp[hour%10];
 202   1              delay(2);
 203   1      
 204   1          LED_CON&=0X0f;       //保持低4位数据不变
 205   1              LED_CON|=(0xbf&0xf0);//
 206   1          P0=table[minute/10];
 207   1          delay(4);   
 208   1      
 209   1          LED_CON&=0X0f;       //保持低4位数据不变
 210   1              LED_CON|=(0x7f&0xf0);//
 211   1          P0=table_dp[minute%10];
 212   1          delay(4);
 213   1      
 214   1       }
 215          
 216          /*************18B20驱动程序************************/
 217           //******************************************
 218            //延时函数
 219            //*****************************************
 220           
 221            void delay1(unsigned int us)
 222             {
 223   1         while(us--);
 224   1         }
 225             //******************************************
 226             //ds18b20复位函数
 227             //******************************************
 228             void reset(void)
 229             {
 230   1          uchar x;//
 231   1          dq=1;//
 232   1          delay1(8);//延时
 233   1              dq=0;
 234   1              delay1(80); //拉低持续480~960us
 235   1              dq=1; //
 236   1              delay1(20);//拉高持续60~120us
 237   1              x=dq;
 238   1              delay1(20);
 239   1          }
 240           //******************************************
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 5   

 241           //从ds18b20中读一个字节
 242           //******************************************
 243           uchar readbyte(void)
 244           {uchar i,value;
 245   1        
 246   1        for(i=0;i<8;i++)
 247   1        {dq=0;
 248   2         value>>=1;
 249   2         dq=1;
 250   2         if(dq)
 251   2         value|=0x80;
 252   2         delay1(4);//延时让单片机采样
 253   2         }
 254   1        return(value);
 255   1        }
 256              //****************************************
 257           // 从ds18b20中写一个字节
 258           //***************************************
 259           void writebyte(uchar dat)
 260           {
 261   1        uchar i=0;
 262   1        for(i=0;i<8;i++)
 263   1        {dq=0;
 264   2         dq=dat&0x01; //从地位开始写
 265   2         delay1(5); //延时60~120US
 266   2         dq=1;   //   拉高
 267   2         dat>>=1; //右移1位
 268   2         }
 269   1         delay1(4);
 270   1        }
 271          
 272           
 273             
 274             //********************************************
 275            //  从DS18B20中读取实时温度值
 276               //********************************************
 277            uchar readtemp(void)
 278            {
 279   1        
 280   1        uchar a,b;
 281   1       { 
 282   2        reset(); //初始化18b20
 283   2        writebyte(0xcc);//跳过ROM
 284   2        writebyte(0x44);//启动温度测量
 285   2        delay1(50);
 286   2      
 287   2        reset(); //初始化18b20
 288   2        writebyte(0xcc);//跳过ROM
 289   2        writebyte(0xbe);//读9个寄存器，前两个温度
 290   2        
 291   2        a=readbyte(); //低位
 292   2        b=readbyte(); //高位
 293   2        if(b>0x0f) //显示负温度
 294   2        {
 295   3        a=~a+1;
 296   3        if(a==0)
 297   3        b=~b+1;
 298   3        else 
 299   3        b=~b;
 300   3        flag=0xff; //显示符号位-
 301   3        }
 302   2        else  //显示正温度
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 6   

 303   2        flag=0x00; //显示符号位+
 304   2        ch=a&0x0f; //小数点位
 305   2        a>>=4;
 306   2        b<<=4;
 307   2        b=b|a;   // 整数位
 308   2        
 309   2        }
 310   1        
 311   1         return(b);
 312   1         }
 313          
 314          
 315          
 316          
 317          
 318          
 319          void disp_temp()//数码显示闹铃函数
 320          {
 321   1          LED_CON&=0X0f;       //保持低4位数据不变,高4位清零
 322   1              LED_CON|=(0xef&0xf0);//
 323   1      
 324   1          P0=table[temp/100];
 325   1          delay(2);
 326   1      
 327   1          LED_CON&=0X0f;       //保持低4位数据不变
 328   1              LED_CON|=(0xdf&0xf0);//
 329   1      
 330   1          P0=table[temp%100/10];  //显示温度十位; 
 331   1              delay(2);
 332   1      
 333   1          LED_CON&=0X0f;       //保持低4位数据不变
 334   1              LED_CON|=(0xbf&0xf0);//
 335   1          P0=table_dp[temp%100%10];
 336   1          delay(4);   
 337   1      
 338   1          LED_CON&=0X0f;       //保持低4位数据不变
 339   1              LED_CON|=(0x7f&0xf0);//
 340   1          P0=table[table2[ch]]; //显示小数位
 341   1          delay(4);
 342   1      
 343   1       }
 344          
 345          
 346          
 347          
 348          
 349           //*******************************
 350           //数码动态扫描函数
 351           //******************************
 352          
 353          
 354          
 355          
 356          void set_time()
 357            
 358          { 
 359   1       
 360   1       bit key20_flag,key21_flag,key22_flag,key23_flag; 
 361   1      
 362   1       if((KEY20==0)&&(key20_flag==0))
 363   1      {
 364   2      delay(10);
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 7   

 365   2      if((KEY20==0)&&(key20_flag==0))
 366   2       {
 367   3      time_flag++;
 368   3      if(time_flag==3)
 369   3      time_flag=0;
 370   3      
 371   3      key20_flag=1;
 372   3      }
 373   2      }
 374   1      if(KEY20==1)
 375   1      {
 376   2      key20_flag=0;
 377   2      
 378   2      }
 379   1      
 380   1       if((KEY21==0)&&(key21_flag==0))
 381   1      {
 382   2      delay(10);
 383   2      if((KEY21==0)&&(key21_flag==0))
 384   2       {
 385   3       if(time_flag==2)
 386   3       {
 387   4      hour++;;
 388   4      if(hour==24)
 389   4      hour=0;
 390   4      set_rtc(0X84,hour);
 391   4      key21_flag=1;
 392   4      }
 393   3      }
 394   2      }
 395   1      if(KEY21==1)
 396   1      {
 397   2      key21_flag=0;
 398   2      }
 399   1      
 400   1      if((KEY22==0)&&(key22_flag==0))
 401   1      {
 402   2      delay(10);
 403   2      if((KEY22==0)&&(key22_flag==0))
 404   2       {
 405   3       if(time_flag==2)
 406   3       {
 407   4        minute++;;
 408   4       if(minute==60)
 409   4       minute=0;
 410   4      set_rtc(0X82,minute);
 411   4      
 412   4        set_rtc(0X80,0);      //设定秒
 413   4       // set_rtc(0X82,16);   //设定分
 414   4       // set_rtc(0X84,22);   //设定小时
 415   4        set_rtc(0X86,1);      //设定日期
 416   4        set_rtc(0X88,11);     //设定月份
 417   4        set_rtc(0X8A,1);      //设定星期
 418   4        set_rtc(0X8C,11);      //设定年份
 419   4      
 420   4      key22_flag=1;
 421   4      }
 422   3      }
 423   2      }
 424   1      if(KEY22==1)
 425   1      {
 426   2      key22_flag=0;
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 8   

 427   2      }
 428   1      
 429   1      if((KEY23==0)&&(key23_flag==0))
 430   1      {
 431   2      delay(10);
 432   2      if((KEY23==0)&&(key23_flag==0))
 433   2       {
 434   3       
 435   3      bell_flag=~bell_flag;
 436   3      bell1=bell_flag;
 437   3      key23_flag=1;
 438   3      }
 439   2      }
 440   1      if(KEY23==1)
 441   1      {
 442   2      key23_flag=0;
 443   2      }
 444   1      
 445   1      
 446   1      
 447   1      }
 448          
 449          void main(void)   
 450              { 
 451   1              bell1=1;
 452   1              bell_flag=1;
 453   1        //  set_rtc(0X80,50);
 454   1              while(1)
 455   1              {
 456   2               time_proce(); //1302时间处理函数
 457   2               read_rtc();       //实时时钟函数
 458   2           temp=readtemp();   //读取温度程序
 459   2               set_time();     //设定时间程序
 460   2               bell_clock(); //设定闹铃开关程序
 461   2      
 462   2        
 463   2              if(time_flag==0)
 464   2              {
 465   3          disp_time();//数码显示时间函数
 466   3           }
 467   2         if(time_flag==1)
 468   2              {
 469   3                      disp_temp();//显示温度程序
 470   3              }
 471   2          if(time_flag==2)
 472   2              {
 473   3              disp_set_time(); //设定设定时间程序
 474   3              }
 475   2          
 476   2          
 477   2                
 478   2              }
 479   1              }
 480          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1126    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     55       3
C51 COMPILER V9.01   1                                                                     08/26/2012 00:01:02 PAGE 9   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
