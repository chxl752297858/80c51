C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE Main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2           * ADXL345模块
   3           * 
   4           * 用途：ADXL345模块IIC测试程序
   5           * 
   6           * 作者                                 日期                            备注
   7           * Huafeng Lin                  2010/12/10                      新增
   8           * Huafeng Lin                  2010/12/11                      修改
   9           * 
  10           */
  11          
  12          #include  <REG51.H>     
  13          #include  <math.h>    //Keil library  
  14          #include  <stdio.h>   //Keil library    
  15          #include  <INTRINS.H>
  16          #define   uchar unsigned char
  17          #define   uint unsigned int     
  18          #define   DataPort P2    //LCD1602数据端口
  19          sbit      SCL=P1^4;      //IIC时钟引脚定义
  20          sbit      SDA=P1^3;      //IIC数据引脚定义
  21          
  22          sbit      LCM_RS=P1^2;   //LCD1602命令端口              
  23          sbit      LCM_RW=P1^1;   //LCD1602命令端口              
  24          sbit      LCM_EN=P1^0;   //LCD1602命令端口
  25          
  26          #define SlaveAddress   0xA6       //定义器件在IIC总线中的从地址,根据ALT  ADDRESS地址引脚不同修改
  27                                        //ALT  ADDRESS引脚接地时地址为0xA6，接电源时地址为0x3A
  28          typedef unsigned char  BYTE;
  29          typedef unsigned short WORD;
  30          
  31          BYTE BUF[8];                         //接收数据缓存区           
  32          uchar ge,shi,bai,qian,wan;           //显示变量
  33          int  dis_data;                       //变量
  34          
  35          void delay(unsigned int k);
  36          void InitLcd();                      //初始化lcd1602
  37          void Init_ADXL345(void);             //初始化ADXL345
  38          
  39          void WriteDataLCM(uchar dataW);
  40          void WriteCommandLCM(uchar CMD,uchar Attribc);
  41          void DisplayOneChar(uchar X,uchar Y,uchar DData);
  42          void conversion(uint temp_data);
  43          
  44          void  Single_Write_ADXL345(uchar REG_Address,uchar REG_data);   //单个写入数据
  45          uchar Single_Read_ADXL345(uchar REG_Address);                   //单个读取内部寄存器数据
  46          void  Multiple_Read_ADXL345();                                  //连续的读取内部寄存器数据
  47          //------------------------------------
  48          void Delay5us();
  49          void Delay5ms();
  50          void ADXL345_Start();
  51          void ADXL345_Stop();
  52          void ADXL345_SendACK(bit ack);
  53          bit  ADXL345_RecvACK();
  54          void ADXL345_SendByte(BYTE dat);
  55          BYTE ADXL345_RecvByte();
C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 2   

  56          void ADXL345_ReadPage();
  57          void ADXL345_WritePage();
  58          //-----------------------------------
  59          
  60          //*********************************************************
  61          void conversion(uint temp_data)  
  62          {  
  63   1          wan=temp_data/10000+0x30 ;
  64   1          temp_data=temp_data%10000;   //取余运算
  65   1              qian=temp_data/1000+0x30 ;
  66   1          temp_data=temp_data%1000;    //取余运算
  67   1          bai=temp_data/100+0x30   ;
  68   1          temp_data=temp_data%100;     //取余运算
  69   1          shi=temp_data/10+0x30    ;
  70   1          temp_data=temp_data%10;      //取余运算
  71   1          ge=temp_data+0x30;  
  72   1      }
  73          
  74          /*******************************/
  75          void delay(unsigned int k)      
  76          {                                               
  77   1      unsigned int i,j;                               
  78   1      for(i=0;i<k;i++)
  79   1      {                       
  80   2      for(j=0;j<121;j++)                      
  81   2      {;}}                                            
  82   1      }
  83          /*******************************/
  84          void WaitForEnable(void)        
  85          {                                       
  86   1      DataPort=0xff;          
  87   1      LCM_RS=0;LCM_RW=1;_nop_();
  88   1      LCM_EN=1;_nop_();_nop_();
  89   1      while(DataPort&0x80);   
  90   1      LCM_EN=0;                               
  91   1      }                                       
  92          /*******************************/
  93          void WriteCommandLCM(uchar CMD,uchar Attribc)
  94          {                                       
  95   1      if(Attribc)WaitForEnable();     
  96   1      LCM_RS=0;LCM_RW=0;_nop_();
  97   1      DataPort=CMD;_nop_();   
  98   1      LCM_EN=1;_nop_();_nop_();LCM_EN=0;
  99   1      }                                       
 100          /*******************************/
 101          void WriteDataLCM(uchar dataW)
 102          {                                       
 103   1      WaitForEnable();                
 104   1      LCM_RS=1;LCM_RW=0;_nop_();
 105   1      DataPort=dataW;_nop_(); 
 106   1      LCM_EN=1;_nop_();_nop_();LCM_EN=0;
 107   1      }               
 108          /***********************************/
 109          void InitLcd()                          
 110          {                       
 111   1      WriteCommandLCM(0x38,1);        
 112   1      WriteCommandLCM(0x08,1);        
 113   1      WriteCommandLCM(0x01,1);        
 114   1      WriteCommandLCM(0x06,1);        
 115   1      WriteCommandLCM(0x0c,1);
 116   1      }                       
 117          /***********************************/
C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 3   

 118          void DisplayOneChar(uchar X,uchar Y,uchar DData)
 119          {                                               
 120   1      Y&=1;                                           
 121   1      X&=15;                                          
 122   1      if(Y)X|=0x40;                                   
 123   1      X|=0x80;                        
 124   1      WriteCommandLCM(X,0);           
 125   1      WriteDataLCM(DData);            
 126   1      }                                               
 127          
 128          /**************************************
 129          延时5微秒(STC90C52RC@12M)
 130          不同的工作环境,需要调整此函数，注意时钟过快时需要修改
 131          当改用1T的MCU时,请调整此延时函数
 132          **************************************/
 133          void Delay5us()
 134          {
 135   1          _nop_();_nop_();_nop_();_nop_();
 136   1          _nop_();_nop_();_nop_();_nop_();
 137   1              _nop_();_nop_();_nop_();_nop_();
 138   1      }
 139          
 140          /**************************************
 141          延时5毫秒(STC90C52RC@12M)
 142          不同的工作环境,需要调整此函数
 143          当改用1T的MCU时,请调整此延时函数
 144          **************************************/
 145          void Delay5ms()
 146          {
 147   1          WORD n = 560;
 148   1      
 149   1          while (n--);
 150   1      }
 151          
 152          /**************************************
 153          起始信号
 154          **************************************/
 155          void ADXL345_Start()
 156          {
 157   1          SDA = 1;                    //拉高数据线
 158   1          SCL = 1;                    //拉高时钟线
 159   1          Delay5us();                 //延时
 160   1          SDA = 0;                    //产生下降沿
 161   1          Delay5us();                 //延时
 162   1          SCL = 0;                    //拉低时钟线
 163   1      }
 164          
 165          /**************************************
 166          停止信号
 167          **************************************/
 168          void ADXL345_Stop()
 169          {
 170   1          SDA = 0;                    //拉低数据线
 171   1          SCL = 1;                    //拉高时钟线
 172   1          Delay5us();                 //延时
 173   1          SDA = 1;                    //产生上升沿
 174   1          Delay5us();                 //延时
 175   1      }
 176          
 177          /**************************************
 178          发送应答信号
 179          入口参数:ack (0:ACK 1:NAK)
C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 4   

 180          **************************************/
 181          void ADXL345_SendACK(bit ack)
 182          {
 183   1          SDA = ack;                  //写应答信号
 184   1          SCL = 1;                    //拉高时钟线
 185   1          Delay5us();                 //延时
 186   1          SCL = 0;                    //拉低时钟线
 187   1          Delay5us();                 //延时
 188   1      }
 189          
 190          /**************************************
 191          接收应答信号
 192          **************************************/
 193          bit ADXL345_RecvACK()
 194          {
 195   1          SCL = 1;                    //拉高时钟线
 196   1          Delay5us();                 //延时
 197   1          CY = SDA;                   //读应答信号
 198   1          SCL = 0;                    //拉低时钟线
 199   1          Delay5us();                 //延时
 200   1      
 201   1          return CY;
 202   1      }
 203          
 204          /**************************************
 205          向IIC总线发送一个字节数据
 206          **************************************/
 207          void ADXL345_SendByte(BYTE dat)
 208          {
 209   1          BYTE i;
 210   1      
 211   1          for (i=0; i<8; i++)         //8位计数器
 212   1          {
 213   2              dat <<= 1;              //移出数据的最高位
 214   2              SDA = CY;               //送数据口
 215   2              SCL = 1;                //拉高时钟线
 216   2              Delay5us();             //延时
 217   2              SCL = 0;                //拉低时钟线
 218   2              Delay5us();             //延时
 219   2          }
 220   1          ADXL345_RecvACK();
 221   1      }
 222          
 223          /**************************************
 224          从IIC总线接收一个字节数据
 225          **************************************/
 226          BYTE ADXL345_RecvByte()
 227          {
 228   1          BYTE i;
 229   1          BYTE dat = 0;
 230   1      
 231   1          SDA = 1;                    //使能内部上拉,准备读取数据,
 232   1          for (i=0; i<8; i++)         //8位计数器
 233   1          {
 234   2              dat <<= 1;
 235   2              SCL = 1;                //拉高时钟线
 236   2              Delay5us();             //延时
 237   2              dat |= SDA;             //读数据               
 238   2              SCL = 0;                //拉低时钟线
 239   2              Delay5us();             //延时
 240   2          }
 241   1          return dat;
C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 5   

 242   1      }
 243          
 244          //******单字节写入*******************************************
 245          
 246          void Single_Write_ADXL345(uchar REG_Address,uchar REG_data)
 247          {
 248   1          ADXL345_Start();                  //起始信号
 249   1          ADXL345_SendByte(SlaveAddress);   //发送设备地址+写信号
 250   1          ADXL345_SendByte(REG_Address);    //内部寄存器地址，请参考中文pdf22页 
 251   1          ADXL345_SendByte(REG_data);       //内部寄存器数据，请参考中文pdf22页 
 252   1          ADXL345_Stop();                   //发送停止信号
 253   1      }
 254          
 255          //********单字节读取*****************************************
 256          uchar Single_Read_ADXL345(uchar REG_Address)
 257          {  uchar REG_data;
 258   1          ADXL345_Start();                          //起始信号
 259   1          ADXL345_SendByte(SlaveAddress);           //发送设备地址+写信号
 260   1          ADXL345_SendByte(REG_Address);            //发送存储单元地址，从0开始       
 261   1          ADXL345_Start();                          //起始信号
 262   1          ADXL345_SendByte(SlaveAddress+1);         //发送设备地址+读信号
 263   1          REG_data=ADXL345_RecvByte();              //读出寄存器数据
 264   1              ADXL345_SendACK(1);   
 265   1              ADXL345_Stop();                           //停止信号
 266   1          return REG_data; 
 267   1      }
 268          //*********************************************************
 269          //
 270          //连续读出ADXL345内部加速度数据，地址范围0x32~0x37
 271          //
 272          //*********************************************************
 273          void Multiple_read_ADXL345(void)
 274          {   uchar i;
 275   1          ADXL345_Start();                          //起始信号
 276   1          ADXL345_SendByte(SlaveAddress);           //发送设备地址+写信号
 277   1          ADXL345_SendByte(0x32);                   //发送存储单元地址，从0x32开始    
 278   1          ADXL345_Start();                          //起始信号
 279   1          ADXL345_SendByte(SlaveAddress+1);         //发送设备地址+读信号
 280   1               for (i=0; i<6; i++)                      //连续读取6个地址数据，存储中BUF
 281   1          {
 282   2              BUF[i] = ADXL345_RecvByte();          //BUF[0]存储0x32地址中的数据
 283   2              if (i == 5)
 284   2              {
 285   3                 ADXL345_SendACK(1);                //最后一个数据需要回NOACK
 286   3              }
 287   2              else
 288   2              {
 289   3                ADXL345_SendACK(0);                //回应ACK
 290   3             }
 291   2         }
 292   1          ADXL345_Stop();                          //停止信号
 293   1          Delay5ms();
 294   1      }
 295          
 296          
 297          //*****************************************************************
 298          
 299          //初始化ADXL345，根据需要请参考pdf进行修改************************
 300          void Init_ADXL345()
 301          {
 302   1         Single_Write_ADXL345(0x31,0x0B);   //测量范围,正负16g，13位模式
 303   1         Single_Write_ADXL345(0x2C,0x08);   //速率设定为12.5 参考pdf13页
C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 6   

 304   1         Single_Write_ADXL345(0x2D,0x08);   //选择电源模式   参考pdf24页
 305   1         Single_Write_ADXL345(0x2E,0x80);   //使能 DATA_READY 中断
 306   1         Single_Write_ADXL345(0x1E,0x00);   //X 偏移量 根据测试传感器的状态写入pdf29页
 307   1         Single_Write_ADXL345(0x1F,0x00);   //Y 偏移量 根据测试传感器的状态写入pdf29页
 308   1         Single_Write_ADXL345(0x20,0x05);   //Z 偏移量 根据测试传感器的状态写入pdf29页
 309   1      }
 310          //***********************************************************************
 311          //显示x轴
 312          void display_x()
 313          {   float temp;
 314   1          dis_data=(BUF[1]<<8)+BUF[0];  //合成数据   
 315   1              if(dis_data<0){
 316   2              dis_data=-dis_data;
 317   2          DisplayOneChar(10,0,'-');      //显示正负符号位
 318   2              }
 319   1              else DisplayOneChar(10,0,' '); //显示空格
 320   1      
 321   1          temp=(float)dis_data*3.9;  //计算数据和显示,查考ADXL345快速入门第4页
 322   1          conversion(temp);          //转换出显示需要的数据
 323   1              DisplayOneChar(8,0,'X');
 324   1          DisplayOneChar(9,0,':'); 
 325   1          DisplayOneChar(11,0,qian); 
 326   1              DisplayOneChar(12,0,'.'); 
 327   1          DisplayOneChar(13,0,bai); 
 328   1          DisplayOneChar(14,0,shi); 
 329   1              DisplayOneChar(15,0,' '); 
 330   1      }
 331          
 332          //***********************************************************************
 333          //显示y轴
 334          void display_y()
 335          {     float temp;
 336   1          dis_data=(BUF[3]<<8)+BUF[2];  //合成数据   
 337   1              if(dis_data<0){
 338   2              dis_data=-dis_data;
 339   2          DisplayOneChar(2,1,'-');      //显示正负符号位
 340   2              }
 341   1              else DisplayOneChar(2,1,' '); //显示空格
 342   1      
 343   1          temp=(float)dis_data*3.9;  //计算数据和显示,查考ADXL345快速入门第4页
 344   1          conversion(temp);          //转换出显示需要的数据
 345   1              DisplayOneChar(0,1,'Y');   //第1行，第0列 显示y
 346   1          DisplayOneChar(1,1,':'); 
 347   1          DisplayOneChar(3,1,qian); 
 348   1              DisplayOneChar(4,1,'.'); 
 349   1          DisplayOneChar(5,1,bai); 
 350   1          DisplayOneChar(6,1,shi);  
 351   1              DisplayOneChar(7,1,' ');  
 352   1      }
 353          
 354          //***********************************************************************
 355          //显示z轴
 356          void display_z()
 357          {
 358   1          float temp;
 359   1          dis_data=(BUF[5]<<8)+BUF[4];    //合成数据   
 360   1              if(dis_data<0){
 361   2              dis_data=-dis_data;
 362   2          DisplayOneChar(10,1,'-');       //显示负符号位
 363   2              }
 364   1              else DisplayOneChar(10,1,' ');  //显示空格
 365   1      
C51 COMPILER V9.01   MAIN                                                                  10/11/2012 18:49:16 PAGE 7   

 366   1          temp=(float)dis_data*3.9;  //计算数据和显示,查考ADXL345快速入门第4页
 367   1          conversion(temp);          //转换出显示需要的数据
 368   1              DisplayOneChar(8,1,'Z');  //第0行，第10列 显示Z
 369   1          DisplayOneChar(9,1,':'); 
 370   1          DisplayOneChar(11,1,qian); 
 371   1              DisplayOneChar(12,1,'.'); 
 372   1          DisplayOneChar(13,1,bai); 
 373   1          DisplayOneChar(14,1,shi); 
 374   1              DisplayOneChar(15,1,' ');  
 375   1      }
 376          
 377          
 378          //*********************************************************
 379          //******主程序********
 380          //*********************************************************
 381          void main()
 382          { 
 383   1              uchar devid;
 384   1              delay(500);                             //上电延时              
 385   1              InitLcd();                      //液晶初始化ADXL345
 386   1              
 387   1              DisplayOneChar(0,0,'A');
 388   1              DisplayOneChar(1,0,'D'); 
 389   1              DisplayOneChar(2,0,'X'); 
 390   1              DisplayOneChar(3,0,'L'); 
 391   1              DisplayOneChar(4,0,'3'); 
 392   1              DisplayOneChar(5,0,'4');  
 393   1              DisplayOneChar(6,0,'5'); 
 394   1              
 395   1              Init_ADXL345();                         //初始化ADXL345
 396   1              devid=Single_Read_ADXL345(0X00);        //读出的数据为0XE5,表示正确
 397   1              while(1)                                //循环
 398   1              { 
 399   2                      Multiple_Read_ADXL345();        //连续读出数据，存储在BUF中
 400   2                      display_x();                    //---------显示X轴
 401   2                      display_y();                    //---------显示Y轴
 402   2                      display_z();                    //---------显示Z轴
 403   2                      delay(200);                     //延时            
 404   2              }
 405   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1015    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
